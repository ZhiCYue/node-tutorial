## TCP

Node HTTP 服务是构建于 Node TCP 服务器之上的。从编程角度来说，也就是 Node 中的 http.Server 集成自 net.Server (net 是 TCP 模块)。

<br>
> 除了 web 浏览器和服务器 (HTTP) 之外，日常中的邮件客户端（SMTP/IMAP/POP）、聊天程序（IRC/XMPP）以及远程 shell（SSH）等都基于 TCP 协议。

> TCP 的主要特点就是它是面向连接的。TCP 基于 IP 协议，IP 协议是无连接的。

> IP 是基于数据报的传输。这些数据报是独立进行传输的，送达的顺序也是无序的。

那么，TCP 是如何保证独立的数据报送达的时候是有序的？

<br>
使用 IP 协议意味着数据报送达时是无序的，这些数据报不属于任何的数据流或者连接，那么当使用 TCP/IP 和服务器建立连接后，是怎样做到让数据包有序呢？
<br>
回答上面问题，等同于在解释为何会有 TCP。当在 TCP 连接内进行数据传递时，发送的 IP 数据报包含了标识该连接以及数据流顺序的信息。
<br>
假设一条消息分割为四个部分，当服务器从连接 A 收到第一部分和第四部分后，他就知道还要等待其他数据报中的第二部分和第三部分。


#### 面向字节

TCP 对字符以及字符编码是完全无知的。TCP 允许数据以 ASCII 字符（每个字符一个字节）或者 Unicode （即每个字符四个字节）进行传输。

#### 可靠性

TCP 当数据发送出去后，发送方就会等待一个确认消息（表示数据包已经收到的简短的确认消息），如果过了指定的窗口时间，还未收到确认消息，发送方就会对数据进行重发。

<br>
这种机制有效地解决了如网络错误或者网络阻塞这样的不可预测的情况。

#### 流控制

如果两台相互通信的计算机中，有一台速度远快于另外一台，会怎么样？
<br>
TCP 会通过一种叫做流控制的方式来确保两点直接传输数据的平衡。

#### 拥堵控制

TCP 有一种内置的机制能够控制数据包的延迟率及丢包率不会太高，以此来保证服务的质量。举个栗子，和流控制机构能够避免发送方压垮接收方一样，TCP 会通过控制数据包的传输速率来避免拥堵的情况。

#### Telnet

Telnet 是一个早期的网络协议，只在提供双向的虚拟终端。Telnet 是 TCP 协议上层的协议。

> 绝大部分 Telnet 使用的是 23 端口。

telnet 过程：

- 成功建立了一个 TCP 连接
- 创建一个 HTTP 请求
- 接收到了一个 HTTP 响应


## 基于 TCP 的聊天程序

见示例代码 tcp-chat.
<br>
createServer 回调函数会接受一个对象，该对象是 Node 中一个很常见的实例：流（Stream）。tcp-chat 示例中，它传递的是 net.Steam,该对象通常是即可读又可写的。
> `conn.on('close', function () {})` 当套接字关闭时，Node.js 会触发 close 事件。<br>
> 1.Node 中有两个和连接终止相关的事件：end 和 close。前者是当客户端显示关闭 TCP 连接时触发。比如，当你关闭 telnet 时，它会发送一个名为“FIN” 的包给服务器，意味着结束连接。<br>
> 当连接发生错误时（触发 error 事件），end 事件不会触发，因为服务端不会收到“FIN” 包，而 close 事件会触发。这也就是示例中用 close 而非 end 的原因。

和其他 Node 中的 API 一样，net.Stream 同时也是一个 EventEmitter。
<br>
`conn.on('data', function (data) {})` 该行代码接收到的 data 是一个 Buffer。TCP 是面向字节的协议。这个时候有多种选择可以获取字符串形式的数据。
> 可以利用 Buffer 的 toString('utf-8') 来获取。
> 也可以通过 net.Stream#setEncoding 方法来设置编码

