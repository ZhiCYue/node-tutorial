## Node 阻塞与非阻塞

`tutorial-01`
<br/>
#### 共享状态的并发

假设一个用户分别向 Node 服务器和 PHP 服务器各同时发起两次对 /books 的请求。两者的区别：
- Node 会完整的将图书信息返回给第一个请求；而第二个请求则会返回一个空的图书列表。
- PHP 都能完整的将图书列表返回给两个请求。

```   
      +-----------------------+
      |        Apache         |
      +-+---------+---------+-+
        |         |         |
    +---+         |         +---+
+---+---+     +---+---+     +---+---+
|  Thd  |     |  Thd  |     |  Thd  |
+---+---+     +---+---+     +---+---+
    |             |             |
+---+---+     +---+---+     +---+---+
|  Req  |     |  Req  |     |  Req  |
+-------+     +-------+     +-------+

```
```
+-----------------------------------+
|                                   |
|           Node.js Process         |
|                                   |
+----+------------+------------+----+
     |            |            |
+----+----+  +----+----+  +----+----+
|   Req   |  |   Req   |  |   Req   |
+---------+  +---------+  +---------+

```

#### 阻塞

Node 的并发实现采用的是事件轮询。与settimeout 采用的技术一样，所有像 http、net 这样的原生模块中的 IO 部分也都采用事件轮询。

#### 单线程世界

Node 是单线程的。在没有第三方模块的帮助下是无法改变这一事实的。
例如：一段脚本中，两个timeout，当第一个事件分发时，会执行回调函数，由于回调函数需要执行很长一段时间（循环次数太多），所以下一个事件循环执行的时间就远远超过示例中的 2 秒。
> http 请求和其他的 IO 均可能出现示例情况。（优秀的 Node 模块都是非阻塞的，执行任务采用了异步的方式）

？既然执行时只有一个线程，当一个函数在执行时，同一时间内不可能有第二个函数执行，那 Node 是如何实现高并发的呢<br>
？一台普通笔记本的简单 Node 服务如何在一秒钟处理上千的请求呢

**回答**：当 Node 调用堆栈展开时，Node 就无法处理其他的客户端或 http 请求了。但是由于 V8 搭配非阻塞 IO，V8 执行 JS 非常之快，非阻塞 IO 确保了单线程执行时，不会因为有数据库访问或者磁盘访问等操作而导致被挂起。

#### 错误处理

之前所说，Node 应用依托于一个拥有大量共享状态的大进程中。例如，一个 HTTP 请求中，如果某个回调函数发生了错误，整个进程都会遭殃：
```js
var http = require('http')

http.createServer(function() {
  throw new Error('错误不会被捕获')
}).listen(3000)
```
错误未被捕获，若访问 Web 服务器，进程就会崩溃。

可以添加 uncatchException 处理器，添加后，进程就不会退出：
```js
process.on('uncatchException', function (err) {
  console.log(err)
  process.exit(1)
})
```


#### 堆栈追踪

在js 中，当发生错误时，会看到一些列的函数调用，成为堆栈追踪。